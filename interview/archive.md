## TS 中 type 和 interface 有什么区别？

1. 从基础定义看，type 可定义基本类型、联合类型（A | B）、交叉类型（A & B）；interface 更专注于对象类型的定义。
2. 从扩展性看，type 一旦定义不可修改，需要通过交叉类型扩展；interface 支持继承和同名合并，适合动态扩展的对象。
3. 在实践中，当需要强约束对象结构时，优先使用 interface，因为它支持合并和继承；当需要组合简单类型（如函数参数的枚举状态），type 更合适。

## TS 中 never 和 void 有什么区别？

1. never 表示不可能存在的值，这类函数永远不会有返回值；void 表示有效值缺失，这类函数正常结束但没有返回值。
2. 在实践中，never 通常用于抛出异常或无限循环，void 用于表示函数无返回值。

## TS 中 any 和 unkown 有什么区别？

1. any 表示完全无类型限制；unkown 表示类型安全的未知，必须通过类型断言或类型检查后才能使用。
2. 在实践中，any 可以临时规避类型检查；unkown 明确表示值的类型不确定，但需保持类型安全。

## 说一说你对依赖注入的理解

依赖注入是一种设计模式，它通过将组件所需的依赖从外部注入，而非在组件内部直接创建或硬编码。它的核心是控制反转（IoC），即依赖对象的控制权交给外部容器或调用方，从而解耦组件之间的关系。

在实践中，常见的依赖注入方式有：

1. 构造函数注入：通过类的构造函数传递依赖。
2. 属性或方法注入：通过设置属性或方法传递依赖。
3. 依赖注入容器：使用库集中管理依赖的生命周期和注入逻辑。

## 说一说 TS 中的装饰器

装饰器是 TS 中的一种特殊语法，本质上是一个函数，可以附加到类、方法、属性或参数上，用于动态扩展或修改类的行为。

装饰器是基于装饰器模式，在不修改原有类的基础上，通过包装增强功能。

在实践中，常见的装饰器有：

1. 类装饰器：用于监听或修改类的构造函数，如实现单例模式或注册服务到容器
2. 方法装饰器：用于监听或修改方法的行为，如日志、权限控制
3. 属性装饰器：用于监听属性初始化或添加元数据，可以结合反射实现 ORM 字段映射
4. 参数装饰器：用于标记方法参数的元数据，如依赖注入
